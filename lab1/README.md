## Лабораторная 1

Запуск с хорошим докерфайлом:\
`docker build -t ocr_best_1_good . -f good.Dockerfile`\
`docker run -it -e TOKEN=<token here> ocr_best_1_good`

Запуск с плохим докерфайлом:\
`docker build -t ocr_best_1_bad . -f bad.Dockerfile`\
`docker run -it -e TOKEN=<token here> ocr_best_1_bad`

### “bad practices” в bad.Dockerfile, как исправлены в good.Dockerfile
1. Неправильная последовательность run и copy при установке зависимостей

    COPY . .
    RUN apt-get update && apt-get install tesseract-ocr -y
    RUN pip install --no-cache-dir -r requirements.txt

Такая последовательность команд неудачна, поскольку при изменении каких-то файлов (файлов с кодом), команды, начиная с copy, будут выполняться как действия, которые раньше не встречались, и заново будут устанавливаться все библиотеки

Исправлено на

    COPY requirements.txt .
    RUN apt-get update && apt-get install tesseract-ocr -y
    RUN pip install --no-cache-dir -r requirements.txt 
    COPY src src

В этом случае при изменении файлов с кодом будут использоваться уже скачанные слои с библиотеками.

2. Копирование всех файлов
`COPY . .`

Не очень хорошо копировать все файлы, поскольку среди них могут быть объемные ненужные файлы или файлы с конфиденциальной информацией. Поэтому в хорошем докерфайле заменим это на `COPY requirements.txt .` и `COPY src src`

3. Указание не совсем точной версии базового образа
`FROM python:3.10`

Лучше указать точную версию, чтобы не было конфликтов зависимостей:

`FROM python:3.10`


4. Запуск root
В "плохом" докерфайле команды выполняются от лица юзера root. Насколько я понимаю, это потенциально небезопасно в случае попадания вредоносного кода, поэтому создадим группу и пользователя и переключимся на него:

    RUN addgroup --system app && adduser --system --group app

    USER app

5. Игнорирование Python-оптимизаций:

К `RUN pip install -r requirements.txt` добавляем опцию `--no-cache-dir`, поскольку нам не нужен кэш библиотек, а он занимает место.

### Две плохие практики по использованию этого контейнера:
1. Запускать, не следя за ресурсами (памятью и CPU).

2. Помещать конфиденциальную информацию внутрь контейнера.

### Два случая, когда НЕ стоит использовать контейнеры в целом:
1. При высокопроизводительных вычислениях - тратятся время и ресурсы на общения между сервисами, сложнее оптимизировать.

2. Если нужен очень выскокий уровень безопасности, поскольку изоляция неполная (по сравнению с ВМ, например).



